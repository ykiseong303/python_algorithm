''' 
분류 : 다이나믹 프로그래밍
문제 : 1로 만들기 (이코테 예제2)
작성일자 : 2021.05.20
'''

# 목적 : 입력받은 수를 4가지 연산을 통해 1로 만들 수 있는 최소 연산의 수를 출력
# 접근 : 
#       1. 그리디, 완전탐색 등을 통해 풀 수 있는지 확인 
#       2. DP로 풀어야 한다면 조건에 충족하는지 확인
#       2-1. 최적부분구조 : 작은 문제로 큰 문제를 해결할 수 있는지?
#           > d[10]은 d[2]와 d[5] (이전에 구한 값, 작은문제)로 해결할 수 있음
#       2-2. 부분중복문제 : 부분문제가 반복적으로 나타나는지?
#           > d[2], d[3] ... 등은 지속적으로 연산이나타나게됌
#       3. 문제해결을 위한 아이디어 
#           > ai는 i를 1로 만들기 위한 최소 연산횟수 
#           > ai = min(ai-1,ai/2,ai/3,ai/5) + 1 (점화식)
#       4. 탑다운? 바텀업? 
#           > 탑다운의 경우라면 (재귀호출)
#               > 종료조건
#               > 메모이제이션 및 기록여부 확인
#           > 바텀업의 경우라면 (반복문 사용)
#               > 현재위치에서 한단계씩 계산하고 기록해가기

# 바텀업을 사용하는 경우
'''N = int(input())
# 계산 결과를 기록하기 위한 DP테이블 초기화
d = [0] * 30001 # 최대 30000까지라고 했으므로
for i in range(2,N+1) : 
    d[i] = d[i-1] + 1 # 현재위치에서 -1 연산을 수행 
    # 2,3,5,7 등의 소수 이후로는 점점 증가하면서 이 수들의 배수를 DP테이블에 기록하므로
    # 누락되는 값음 없음
    if not i%2 : 
        d[i] = min(d[i], d[i//2]+1) # -1과 2로 나누기 연산(나누는 연산이 들어가므로 +1) 중 더 작은 값을 선택
    if not i%3 : 
        d[i] = min(d[i], d[i//3]+1)
    if not i%5 : 
        d[i] = min(d[i], d[i//5]+1)
print(d[N])'''

# # 탑다운을 사용하는 경우
# N = int(input())
# d = [0] * 30001
# def make(x) : 
#     if d[x] != 0 : 
#         return d[x]
#     d[x] = d[x-1] + 1
#     if not x%2 : 
#         d[x] = min(d[x], make(x//2)+1)
# make(N)
