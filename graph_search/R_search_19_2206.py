'''
분류 : DFS & BFS
문제 : 벽 부수고 이동하기 (백준 2206)
작성일자 : 2021.04.03
'''

# 목적 : 목적지까지 도달하는데 최단경로(벽을 부술수 있다면 1회에 한해서)
# 접근 : 일반적인 간선의비용이 1이므로 bfs를 이용해서 최단거리를 구한다
#       벽을 1개씩 다 지워보는 경우는 인접행렬의 시간복잡도(O(V제곱))이므로 1000x1000의 제곱이된다
#       그러므로 bfs를 딱 한번만 실행해서 구할 수 있어야 하는데, 
#       이를 위해 현재위치를 부순적이 있는지 아닌지를 표현하기 위해 x, y, z의 3차원으로 표현(순서주의, zxy아님)
#       현재 위치에서 쭉 탐색하면서 벽을 부술 수 있다면 부순다. 
#       한턴에 모든 벽을 다 지우면서 가는 거지만, 
#       이미 전의 위치에서 방문한적이 있다면 그 값은 무시한다
#       즉, 벽을 부수는 것을 기준으로 현재위치는 1번 부수고 갈 수 있는 최단거리이다
#       다시 벽을 부수는 경우를 제외하고는 현재 비용이 최소비용인셈 

import sys 
from collections import deque 

def bfs() :
    q = deque()
    q.append([0,0,1]) # 시작위치는 0,0이고 벽을 한번 부실 수 있는 상태이므로 1
    while q : 
        x, y, z = q.popleft()
        if x == N-1 and y == M-1 : # 목적지에 도달했다면
            # 현재 상태(부숴서 왔는지, 아닌지)의 최단 경로 값을 리턴
            return crash[x][y][z] 
        for i in range(4) : 
            nx, ny = x + dx[i], y + dy[i]
            # 범위를 벗어나지 않는지 
            if 0<=nx<N and 0<=ny<M : 
                # 벽이 아니고, 그 위치를 방문한 적이 있다면
                # 두번째 조건이 그냥 z가 아닌 이유는
                # z는 값 자체로는 부순 상태, 아닌 상태를 의미하지만
                # 인덱스의 위치로서 z는 현재상태(부쉈는지 아닌지)의 구분 역할
                if shape[nx][ny] == 0 and crash[nx][ny][z] == 0 : 
                    crash[nx][ny][z] = crash[x][y][z] + 1
                    q.append([nx,ny,z])
                # 벽을 만났는데, 부술 수 있는 상태라면
                elif shape[nx][ny] == 1 and z == 1 : 
                    # 한번밖에 부수지 못함에 주의 (그래서 z의 인데스가 1)
                    # 전진한 칸이 부숴서 진행한 칸임을 표시하기 위해
                    # z=0의 인덱스에 경로를 표시
                    crash[nx][ny][0] = crash[x][y][1] + 1 
                    q.append([nx,ny,0])
    # 큐를 다 돌았는데도 안된다면 도달할 수 없다면 -1을 리턴
    return -1 

N, M = map(int, input().split())
shape = [list(map(int, sys.stdin.readline().strip()))for _ in range(N)]
dx = [-1,1,0,0]
dy = [0,0,-1,1]

# 벽을 부쉈는지 아닌지 확인하기 위해 3차원으로 맵을 구현
# z x y로 z차원의 매트릭스가 아닌, x y z 형태의 1차원 형태로 생성
# 최종적으로 z의 인덱스가 0인지 1인지에 따라 부순적이 있는지, 아닌지를 결정
crash = [[[0]*2 for _ in range(M)]for _ in range(N)]
crash[0][0][1] = 1 # 시작위치에서 1번 부술 수 있는 상태를 표현
print(bfs())