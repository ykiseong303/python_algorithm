'''
분류 : 그리디 알고리즘
문제 : 병든 나이트 (백준 1783번)
작성일자 : 2021.03.06
'''

# 나이트가 움직일 수 있는 방향은 4가지
## 목적 : 나이트가 방문할 수 있는 칸의 최대 개수 출력
## 접근 : 위, 아래로 움직이는 경우가 제일 많이 방문할 수 있음
##       문제의 요지에 도달하기 위해 할 수 있는 현재 최고의 선택을 찾기
##       특수한 경우에 대해서 명확히 설정하기

N, M = map(int, input().split())
if N == 1 : 
    # 아무곳도 움직일 수 없음
    print(1)
elif N == 2 : 
    # 방문칸수 = 이동횟수 + 1 임에 유의
    # 이동횟수가 4미만이면 최대 움직일 수 있는 칸은 처음위치(1) + 3번 이동 (4칸)
    ## N이 2인경우, 위/아래 움직임이 불가하므로 오른쪽 이동만 가능
    ## 오른쪽이동은 (M-1)//2(이동위치) + 1(현재위치)
    print(min(4,(M-1)//2 + 1))
elif N>= 3 :
    if M < 7 : 
        # M이 7미만의 경우 4회이상의 움직임이 불가
        # 가장 많이 갈 수 있는 경우는 위/아래 움직임
        ## 위/아래 움직임은 M칸씩 갈 수 있음
        print(min(4,M))
    else : 
        # N>=3 이고 M>=7인 경우
        ## 4회이상 움직일 수 있음
        ## 최대로 움직이기 위해서는 오른쪽 두번(4개의 움직임은 모두해야하므로) + 위/아래
        ## 오른쪽으로 두번 움직이는 경우 : 3
        ## 두번 움직임 이후 위/아래 움직임 : M-5(앞에 1+오른쪽두번 빼야하므로)
        print(M-5+3)
